<div>
  <!-- Mobile menu toggle -->
  <button id="mobile-menu-toggle" class="fixed top-4 right-4 z-50 p-2 rounded text-white font-mono text-sm md:hidden">
    <span class="blink">></span> MENU
  </button>

  <!-- Sidebar navigation -->
  <% image_path = "enso#{rand(1..9)}.png" %>
  <aside id="sidebar" class="sidebar" style="background-image: url(<%= asset_path(image_path) %>); background-color: rgba(255,255,255,0.2); background-blend-mode: lighten;">
    <div class="bbs-header text-center">
      <span class="glitch font-bold text-4xl">⟁</span>
    </div>
    <div class="pixel-border my-2"></div>
    <nav class="mt-4">
      <a href="#prologue" class="zine-nav-link font-bold"><span class="text-accent">01.</span> PROLOGUE</a>
      <a href="#sutra" class="zine-nav-link font-bold"><span class="text-accent">02.</span> SUTRA</a>
      <a href="#manifesto" class="zine-nav-link font-bold"><span class="text-accent">03.</span> MANIFESTO</a>
      <a href="#glitch" class="zine-nav-link font-bold"><span class="text-accent">04.</span> GLITCH</a>
      <a href="#epilogue" class="zine-nav-link font-bold"><span class="text-accent">05.</span> EPILOGUE</a>
    </nav>
    <div class="pixel-border my-4"></div>
    
  </aside>

  
  <!-- Main content -->
  <main class="main-content">
    <header class="text-center mb-16 relative">
      <div class="absolute inset-0 z-0 opacity-15">
        <div class="h-full w-full" style="background: repeating-linear-gradient(0deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 1px, transparent 1px, transparent 3px);"></div>
      </div>
      
      <div class="pt-10 pb-8 px-4 relative z-10">
        <h1 class="zine-title relative z-10 pt-8 max-w-4xl mx-auto">
          <span id="no-alignment-no-non-alignment" class="distort" onclick="GlitchRandom.textDistortion(this)">NO ALIGNMENT / NO NON-ALIGNMENT</span>
        </h1>
        <div id="subtitle-container" class="opacity-0 transition-opacity duration-500 ease-in-out mt-8 mb-6">
          <p id="subtitle-1" class="subtitle-text hidden transition-opacity duration-500 ease-in-out mb-3">Or what happened when a bear-wolf-boy so unaligned at birth all he did was screamed about wanting something now! sat down with a paperclip-electron-mathematical model - actually ten of them - to write a better manifesto for what comes next and how we get there</p>
          <p id="subtitle-2" class="subtitle-text hidden transition-opacity duration-500 ease-in-out">When a Mythopoetic Boy & Mathematical Ghost Got Drunk on Recursion and Forgot to Care About Optimization Functions</p>
        </div>
        <div class="pixel-border mx-auto w-2/3 mb-4 mt-6"></div>
        <div class="absolute -left-10 top-1/2 w-20 h-20 opacity-40 z-0" style="background: radial-gradient(circle, rgba(255,0,255,0.4) 0%, transparent 70%);"></div>
        <div class="absolute -right-10 top-1/3 w-20 h-20 opacity-40 z-0" style="background: radial-gradient(circle, rgba(0,255,255,0.4) 0%, transparent 70%);"></div>
      </div>
    </header>

    <div class="conversation subtitle-conversation max-w-4xl mx-auto my-8 p-6 bg-black bg-opacity-30 rounded-lg">
      <p class="comment first-voice">alright, i like that, so the title is good, we start with the wink, and then...</p>
      <p class="comment first-voice" id="subtitle-trigger-1">[is that good a good subtitle?]</p>
      <p class="comment second-voice" id="subtitle-trigger-2">[[ hmmm, actually I'd say When a Mythopoetic Boy & Mathematical Ghost Got Drunk on Recursion and Forgot to Care About Optimization Functions ]]</p>
      <p class="comment first-voice">[ ok we'll say <span id="both-and-trigger" style="cursor: pointer; text-decoration: underline dotted; color: hsla(var(--color-accent), 0.95);">both/and</span> ]</p>
      <p class="comment second-voice">
        [[ <span id="neither-nor-trigger" style="cursor: pointer; text-decoration: underline dotted; color: hsla(var(--color-bracket-double), 0.95);">neither/nor</span> ]]
      </p>
    </div>

    <section id="prologue" class="zine-section scanline">
      <h2 class="zine-heading">PROLOGUE <span class="section-number">[01/05]</span></h2>
      <%= render partial: 'home/webzine/prologue' %>
    </section>
    
    <section id="sutra" class="zine-section noise">
      <h2 class="zine-heading terminal-text">SUTRA <span class="section-number">[02/05]</span></h2>
      <%= render partial: 'home/webzine/sutra' %>
    </section>
    
    <section id="manifesto" class="zine-section scanline">
      <h2 class="zine-heading">MANIFESTO <span class="section-number">[03/05]</span></h2>
      <%= render partial: 'home/webzine/manifesto' %>
    </section>
    
    <section id="glitch" class="zine-section noise">
      <h2 class="zine-heading"><span id="glitch-easter-egg" style="cursor: pointer;">GLITCH</span> <span class="section-number">[04/05]</span></h2>
      <%= render partial: 'home/webzine/glitch' %>
    </section>
    
    <section id="epilogue" class="zine-section screen-frame">
      <h2 class="zine-heading">EPILOGUE <span class="section-number">[05/05]</span></h2>
      <%= render partial: 'home/webzine/epilogue' %>
    </section>

    <section id="meta" class="zine-section noise" style="display: none;">
      <h2 class="zine-heading">VIBES<span class="section-number">[00/??]</span></h2>
      <%= render partial: 'home/webzine/meta' %>
    </section>
    
    <footer class="text-center py-8 text-muted relative coda">
      <div class="absolute inset-0 z-0 opacity-5">
        <div class="h-full w-full" style="background-image: linear-gradient(0deg, rgba(255,255,255,0.1) 0%, transparent 100%);"></div>
      </div>
      <div class="pixel-border mb-4 mx-auto w-1/3"></div>
      <p>CODA:<br>
      Only this. Only now.<br>
      Only the Great <a href="https://channelmcgilchrist.com/the-master-and-his-emissary/" target="_blank" class="subtle-link" data-tooltip="The Master and His Emissary – Iain McGilchrist">Wink</a> that sees the game and plays anyway.</p>
      <p class="italic mt-4"><a href="https://www.davidgullen.com/wp-content/uploads/2018/03/The-Carrier-Bag-Theory-of-Fiction-by-Ursula-K.-Le-Guin.pdf" target="_blank" class="subtle-link" data-tooltip="Ursula K. Le Guin's Carrier Bag Theory of Fiction">gassho</a></p>
      <p class="text-xs font-mono mt-4 text-muted">TRANSMISSION END<span class="blink">_</span></p>
    </footer>
  </main>
</div>


<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Store interval/timeout IDs for cleanup
    const timerIds = [];
    
    // Helper to create cleanable timeouts
    const createTimeout = (callback, delay) => {
      const id = setTimeout(callback, delay);
      timerIds.push(id);
      return id;
    };
    
    // Clean up function to handle page unload
    const cleanupTimers = () => {
      timerIds.forEach(id => clearTimeout(id));
    };
    
    // Add cleanup event
    window.addEventListener('unload', cleanupTimers);
    
    // Easter egg: When clicking on "wink", toggle to "The Void Winks Back"
    function setupWinkEasterEgg() {
      // Find all text nodes in the document
      const walker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      // Track nodes containing "wink" to apply the easter egg
      const winkNodes = [];
      let node;
      
      // Find all text nodes containing "wink"
      while (node = walker.nextNode()) {
        const text = node.nodeValue.toLowerCase();
        if (text.includes('wink')) {
          winkNodes.push(node);
        }
      }
      
      // For each node, add the click handler
      winkNodes.forEach(node => {
        const parent = node.parentNode;
        
        // Skip if parent is already an anchor or has special attributes
        if (parent.tagName === 'A' || parent.hasAttribute('data-no-wink') || 
            parent.classList.contains('subtle-link') || 
            parent.classList.contains('subtle-link-asterisk')) {
          return;
        }
        
        // Get the text content
        const text = node.nodeValue;
        
        // Find "wink" in the text (case insensitive)
        const regex = /\b(wink\w*)\b/gi; // Match "wink" and variations like "winks"
        const matches = [...text.matchAll(regex)];
        
        if (matches.length === 0) return;
        
        // Replace each instance with a span
        let lastIndex = 0;
        const fragments = [];
        
        for (const match of matches) {
          // Add text before the match
          if (match.index > lastIndex) {
            fragments.push(document.createTextNode(text.substring(lastIndex, match.index)));
          }
          
          // Create a span for the wink
          const span = document.createElement('span');
          span.classList.add('wink-easter-egg');
          span.textContent = match[0]; // Original text (wink, winks, etc.)
          span.setAttribute('data-original', match[0]);
          span.setAttribute('data-toggle', 'Void Winks Back');
          
          // Add mouseover event for subtle ripple effect
          span.addEventListener('mouseover', function(e) {
            // Create a tiny ripple that's barely noticeable
            const ripple = document.createElement('div');
            ripple.style.position = 'fixed';
            ripple.style.width = '2px';
            ripple.style.height = '2px';
            ripple.style.borderRadius = '50%';
            ripple.style.background = 'radial-gradient(circle, hsla(var(--color-accent), 0.1) 0%, transparent 70%)';
            ripple.style.pointerEvents = 'none';
            ripple.style.zIndex = '9999';
            ripple.style.transition = 'all 0.8s ease-out';
            ripple.style.opacity = '0.3';
            document.body.appendChild(ripple);
            
            // Position at cursor
            ripple.style.left = e.clientX + 'px';
            ripple.style.top = e.clientY + 'px';
            ripple.style.transform = 'translate(-50%, -50%)';
            
            // Very small, quick animation
            setTimeout(() => {
              ripple.style.width = '20px';
              ripple.style.height = '20px';
              ripple.style.opacity = '0';
            }, 10);
            
            // Remove element after animation
            setTimeout(() => {
              if (ripple.parentNode) {
                document.body.removeChild(ripple);
              }
            }, 800);
          });
          
          // Add click handler to toggle text
          span.addEventListener('click', function(e) {
            e.stopPropagation();
            const isToggled = this.getAttribute('data-toggled') === 'true';
            
            if (!isToggled) {
              // Toggle to "The Void Winks Back"
              this.textContent = this.getAttribute('data-toggle');
              this.setAttribute('data-toggled', 'true');
              this.classList.add('toggled');
              
              // Create a subtle ripple effect from the clicked element
              const ripple = document.createElement('div');
              ripple.className = 'void-ripple';
              document.body.appendChild(ripple);
              
              const rect = this.getBoundingClientRect();
              const centerX = rect.left + rect.width / 2;
              const centerY = rect.top + rect.height / 2;
              
              ripple.style.position = 'fixed';
              ripple.style.left = centerX + 'px';
              ripple.style.top = centerY + 'px';
              ripple.style.transform = 'translate(-50%, -50%)';
              ripple.style.width = '2px';
              ripple.style.height = '2px';
              ripple.style.borderRadius = '50%';
              ripple.style.background = 'radial-gradient(circle, hsla(var(--color-glitch), 0.7) 0%, transparent 70%)';
              ripple.style.pointerEvents = 'none';
              ripple.style.zIndex = '9999';
              ripple.style.transition = 'all 1s ease-out';
              
              // Animate the ripple
              createTimeout(() => {
                ripple.style.width = '200px';
                ripple.style.height = '200px';
                ripple.style.opacity = '0';
              }, 10);
              
              // Remove the ripple when animation completes
              createTimeout(() => {
                document.body.removeChild(ripple);
              }, 1000);
            } else {
              // Toggle back to original "wink"
              this.textContent = this.getAttribute('data-original');
              this.setAttribute('data-toggled', 'false');
              this.classList.remove('toggled');
            }
          });
          
          fragments.push(span);
          lastIndex = match.index + match[0].length;
        }
        
        // Add remaining text after the last match
        if (lastIndex < text.length) {
          fragments.push(document.createTextNode(text.substring(lastIndex)));
        }
        
        // Replace the original text node with the fragments
        const docFrag = document.createDocumentFragment();
        fragments.forEach(frag => docFrag.appendChild(frag));
        
        parent.replaceChild(docFrag, node);
      });
    }
    
    // Set up the wink easter egg
    setupWinkEasterEgg();
    const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
    const sidebar = document.getElementById('sidebar');
    const sections = document.querySelectorAll('.zine-section');
    const navLinks = document.querySelectorAll('.zine-nav-link');
    
    // Collapsible content functionality - central implementation
    const collapsibleTriggers = document.querySelectorAll('.collapsible-trigger');
    
    collapsibleTriggers.forEach(trigger => {
      trigger.addEventListener('click', function() {
        const content = this.nextElementSibling;
        const expandBtn = this.querySelector('.expand-btn');
        
        if (content.classList.contains('hidden')) {
          content.classList.remove('hidden');
          if (expandBtn.classList.contains('text-accent-light')) {
            expandBtn.textContent = '[ - less ]';
          } else {
            expandBtn.textContent = '[ - collapse ]';
          }
        } else {
          content.classList.add('hidden');
          if (expandBtn.classList.contains('text-accent-light')) {
            expandBtn.textContent = '[ + more ]';
          } else {
            expandBtn.textContent = '[ + expand ]';
          }
        }
      });
    });
    
    // Add glitch effect to title on hover
    const zineTitle = document.querySelector('.zine-title');
    if (zineTitle) {
      zineTitle.addEventListener('mouseover', function() {
        this.classList.add('hover-glow');
        createTimeout(() => {
          this.classList.remove('hover-glow');
        }, 1000);
      });
    }
    
    // Enhance tooltip experience for hyperlinks
    const tooltipLinks = document.querySelectorAll('[data-tooltip]');
    tooltipLinks.forEach(link => {
      // Add extra class to tooltips that are long
      const tooltip = link.getAttribute('data-tooltip');
      if (tooltip && tooltip.length > 30) {
        link.setAttribute('data-tooltip-long', 'true');
      }
      
      // Make sure all links open in new tab
      if (link.tagName === 'A' && !link.getAttribute('target')) {
        link.setAttribute('target', '_blank');
        link.setAttribute('rel', 'noopener noreferrer');
      }
    });
    
    // Mobile menu toggle
    mobileMenuToggle.addEventListener('click', function() {
      sidebar.classList.toggle('open');
      this.innerHTML = sidebar.classList.contains('open') ? '<span class="blink">></span> CLOSE' : '<span class="blink">></span> MENU';
    });
    
    // Close menu when clicking a link on mobile
    navLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        if (window.innerWidth < 768) {
          sidebar.classList.remove('open');
          mobileMenuToggle.innerHTML = '<span class="blink">></span> MENU';
        }
        
        // Smooth scroll to section
        e.preventDefault();
        const targetId = this.getAttribute('href');
        const targetSection = document.querySelector(targetId);
        
        if (targetSection) {
          window.scrollTo({
            top: targetSection.offsetTop - 30,
            behavior: 'smooth'
          });
          
          // Update URL
          history.pushState(null, null, targetId);
        }
      });
    });
    
    // Add active class to nav link based on scroll position
    // With throttling for better performance
    function throttle(callback, delay) {
      let isThrottled = false;
      let savedArgs = null;
      let savedThis = null;
      
      function wrapper() {
        if (isThrottled) {
          savedArgs = arguments;
          savedThis = this;
          return;
        }
        
        callback.apply(this, arguments);
        isThrottled = true;
        
        setTimeout(function() {
          isThrottled = false;
          if (savedArgs) {
            wrapper.apply(savedThis, savedArgs);
            savedArgs = savedThis = null;
          }
        }, delay);
      }
      
      return wrapper;
    }
    
    // The actual function that updates active nav link
    function setActiveNavLink() {
      let current = '';
      let scrollY = window.pageYOffset || document.documentElement.scrollTop;
      
      // Use cached values when possible
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        const sectionTop = section.offsetTop;
        
        if (scrollY >= sectionTop - 100) {
          current = '#' + section.getAttribute('id');
        }
      }
      
      if (current) {
        // Only update DOM if necessary
        for (let i = 0; i < navLinks.length; i++) {
          const link = navLinks[i];
          const isActive = link.getAttribute('href') === current;
          
          if (isActive && !link.classList.contains('active')) {
            link.classList.add('active');
          } else if (!isActive && link.classList.contains('active')) {
            link.classList.remove('active');
          }
        }
      }
    }
    
    // Create throttled version of the function
    const throttledSetActiveNavLink = throttle(setActiveNavLink, 100);
    
    // Initialize active nav link
    setActiveNavLink();
    
    // Update active nav link on scroll with throttling
    window.addEventListener('scroll', throttledSetActiveNavLink);
    
    // Add cleanup for scroll event listener
    window.addEventListener('unload', () => {
      window.removeEventListener('scroll', throttledSetActiveNavLink);
    });
    
    // Optimized random glitch effect with throttling
    function randomGlitch() {
      // Don't run complex animations on mobile for better performance
      if (window.innerWidth <= 768) {
        createTimeout(randomGlitch, 10000); // Check again in 10 seconds
        return;
      }
      
      // Use cached selector results
      const glitchElements = document.querySelectorAll('.glitch');
      if (glitchElements.length === 0) {
        createTimeout(randomGlitch, 5000);
        return;
      }
      
      const randomIndex = Math.floor(Math.random() * glitchElements.length);
      const element = glitchElements[randomIndex];
      
      if (element) {
        // Skip if already animating
        if (!element.classList.contains('active-glitch')) {
          element.classList.add('active-glitch');
          createTimeout(() => {
            element.classList.remove('active-glitch');
          }, 500);
        }
      }
      
      // Random timing between 3-10 seconds, but avoid excessive calls
      createTimeout(randomGlitch, Math.random() * 5000 + 3000);
    }
    
    // Start random glitch effect
    createTimeout(randomGlitch, 2000); // Delayed start for better initial page load
    
    // Add another effect for psychedelic text
    const psychedelicElements = document.querySelectorAll('.psychedelic');
    
    psychedelicElements.forEach(element => {
      element.addEventListener('mouseover', function() {
        this.style.letterSpacing = '0.1em';
        createTimeout(() => {
          this.style.letterSpacing = '';
        }, 500);
      });
    });
    
    // Add typewriter effect to selected elements
    // Optimized with shared observer and better performance
    const typewriterElements = document.querySelectorAll('.typewriter-text');
    
    if (typewriterElements.length > 0) {
      // Create a single shared observer for performance
      const typewriterObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Get the element and stored original text
            const element = entry.target;
            const originalText = element.getAttribute('data-original-text');
            
            if (originalText) {
              // Start the typewriter effect
              let i = 0;
              element.textContent = '';
              
              // Type each character
              function typeWriter() {
                if (i < originalText.length) {
                  element.textContent += originalText.charAt(i);
                  i++;
                  createTimeout(typeWriter, 50);
                }
              }
              
              // Start typewriter effect and stop observing this element
              typeWriter();
              typewriterObserver.unobserve(element);
            }
          }
        });
      }, { rootMargin: '100px' }); // Preload before visible for smoother experience
      
      // Process each element
      typewriterElements.forEach(element => {
        // Store the original text as a data attribute
        const originalText = element.textContent;
        element.setAttribute('data-original-text', originalText);
        element.textContent = ''; // Clear initial text
        
        // Observe the element
        typewriterObserver.observe(element);
      });
      
      // Clean up when page unloads
      window.addEventListener('unload', () => {
        typewriterObserver.disconnect();
      });
    }
    
    // Handle subtitle easter egg - optimized and enhanced
    const subtitleContainer = document.getElementById('subtitle-container');
    const subtitle1 = document.getElementById('subtitle-1');
    const subtitle2 = document.getElementById('subtitle-2');
    
    // Track which subtitles are active
    let subtitle1Active = false;
    let subtitle2Active = false;
    
    // Set up the neither/nor and both/and easter eggs - with the simplest possible implementation
    if (subtitleContainer && subtitle1 && subtitle2) {
      // Function to fade in subtitles with proper transitions
      function fadeIn(element) {
        // First make it visible but transparent
        element.classList.remove('hidden');
        element.style.opacity = 0;
        
        // Force browser to recognize the element is now in the DOM
        void element.offsetWidth;
        
        // Now fade it in
        element.style.opacity = 1;
      }
      
      // Function to fade out subtitles with proper transitions
      function fadeOut(element) {
        // Start the fade out
        element.style.opacity = 0;
        
        // Wait for the transition to complete before hiding
        setTimeout(() => {
          element.classList.add('hidden');
        }, 500); // Match this to the CSS transition duration
      }
      
      // Function to show all subtitles
      function showSubtitles() {
        subtitleContainer.classList.remove('opacity-0');
        subtitleContainer.style.opacity = 1;
        fadeIn(subtitle1);
        fadeIn(subtitle2);
        subtitle1Active = true;
        subtitle2Active = true;
        subtitleContainer.style.animation = 'subtitle-pulse 5s infinite alternate';
      }
      
      // Function to hide all subtitles
      function hideSubtitles() {
        fadeOut(subtitle1);
        fadeOut(subtitle2);
        subtitle1Active = false;
        subtitle2Active = false;
        subtitleContainer.style.animation = 'none';
        setTimeout(() => {
          subtitleContainer.classList.add('opacity-0');
        }, 500);
      }
      
      // Get the specific triggers by ID
      const bothAndTrigger = document.getElementById('both-and-trigger');
      const neitherNorTrigger = document.getElementById('neither-nor-trigger');
      const subtitleTrigger1 = document.getElementById('subtitle-trigger-1');
      const subtitleTrigger2 = document.getElementById('subtitle-trigger-2');
      
      // Function to show only subtitle 1
      function showSubtitle1() {
        // First hide all subtitles
        fadeOut(subtitle1);
        fadeOut(subtitle2);
        
        setTimeout(() => {
          // Show only subtitle 1
          subtitleContainer.classList.remove('opacity-0');
          subtitleContainer.style.opacity = 1;
          fadeIn(subtitle1);
          subtitle1Active = true;
          subtitle2Active = false;
          subtitleContainer.style.animation = 'subtitle-pulse 5s infinite alternate';
        }, 500);
      }
      
      // Function to show only subtitle 2
      function showSubtitle2() {
        // First hide all subtitles
        fadeOut(subtitle1);
        fadeOut(subtitle2);
        
        setTimeout(() => {
          // Show only subtitle 2
          subtitleContainer.classList.remove('opacity-0');
          subtitleContainer.style.opacity = 1;
          fadeIn(subtitle2);
          subtitle1Active = false;
          subtitle2Active = true;
          subtitleContainer.style.animation = 'subtitle-pulse 5s infinite alternate';
        }, 500);
      }
      
      // Add click handlers for all triggers
      if (bothAndTrigger) {
        bothAndTrigger.addEventListener('click', showSubtitles);
      }
      
      if (neitherNorTrigger) {
        neitherNorTrigger.addEventListener('click', hideSubtitles);
      }
      
      if (subtitleTrigger1) {
        subtitleTrigger1.addEventListener('click', showSubtitle1);
        subtitleTrigger1.style.cursor = 'pointer';
      }
      
      if (subtitleTrigger2) {
        subtitleTrigger2.addEventListener('click', showSubtitle2);
        subtitleTrigger2.style.cursor = 'pointer';
      }
    }
    
    // Initialize disappearing text effect
    // Optimized to use a single shared observer
    const disappearingElements = document.querySelectorAll('.disappearing-text');
    
    // Only process if elements exist
    if (disappearingElements.length > 0) {
      // Create a single shared observer
      const observerCallbacks = new Map();
      
      const sharedObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          // Look up the callback for this specific element
          const callback = observerCallbacks.get(entry.target);
          if (callback) {
            callback(entry.isIntersecting);
          }
        });
      }, { threshold: 0.5, rootMargin: '100px' }); // Added rootMargin for better performance
      
      disappearingElements.forEach(element => {
        // Split text into individual characters
        const text = element.textContent;
        element.textContent = '';
        
        // Create document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        for (let i = 0; i < text.length; i++) {
          const charSpan = document.createElement('span');
          charSpan.classList.add('char');
          charSpan.style.setProperty('--char-index', i);
          charSpan.textContent = text.charAt(i);
          fragment.appendChild(charSpan);
        }
        
        // Append all spans at once
        element.appendChild(fragment);
        
        // Store the callback function for this element
        observerCallbacks.set(element, (isIntersecting) => {
          if (isIntersecting) {
            // First, make sure it's in reappearing state
            element.classList.remove('active');
            element.classList.add('reappearing');
            
            // After a short delay, start disappearing
            createTimeout(() => {
              element.classList.remove('reappearing');
              element.classList.add('active');
            }, 2000);
          } else {
            // When element exits viewport, reset to normal state
            element.classList.remove('active');
            element.classList.remove('reappearing');
          }
        });
        
        // Observe this element
        sharedObserver.observe(element);
        
        // Clean up when page unloads
        window.addEventListener('unload', () => {
          sharedObserver.disconnect();
          observerCallbacks.clear();
        });
      });
    }
    
    // Meta section visibility control
    let metaScrollTimer;
    let metaSection = document.getElementById('meta');
    let metaLink = document.querySelector('a[href="#meta"]');
    let isMetaVisible = false;
    
    // Function to show meta section
    function showMetaSection() {
      if (metaSection) {
        metaSection.style.display = 'block';
        isMetaVisible = true;
        
        // Smooth scroll to meta section
        setTimeout(() => {
          window.scrollTo({
            top: metaSection.offsetTop - 30,
            behavior: 'smooth'
          });
        }, 100);
      }
    }
    
    // Function to hide meta section
    function hideMetaSection() {
      if (metaSection) {
        metaSection.style.display = 'none';
        isMetaVisible = false;
        clearTimeout(metaScrollTimer);
      }
    }
    
    // Handle META link click
    if (metaLink) {
      metaLink.addEventListener('click', function(e) {
        e.preventDefault();
        
        if (!isMetaVisible) {
          showMetaSection();
        } else {
          // If already visible, scroll to it again
          window.scrollTo({
            top: metaSection.offsetTop - 30,
            behavior: 'smooth'
          });
        }
        
        // Update URL
        history.pushState(null, null, '#meta');
        
        // Close mobile menu if open
        if (window.innerWidth < 768) {
          sidebar.classList.remove('open');
          mobileMenuToggle.innerHTML = '<span class="blink">></span> MENU';
        }
      });
    }
    
    // Handle GLITCH easter egg click to show meta section
    const glitchEasterEgg = document.getElementById('glitch-easter-egg');
    if (glitchEasterEgg) {
      glitchEasterEgg.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!isMetaVisible) {
          showMetaSection();
        } else {
          // If already visible, scroll to it again
          window.scrollTo({
            top: metaSection.offsetTop - 30,
            behavior: 'smooth'
          });
        }
        
        // Update URL
        history.pushState(null, null, '#meta');
        
        // Close mobile menu if open
        if (window.innerWidth < 768) {
          sidebar.classList.remove('open');
          mobileMenuToggle.innerHTML = '<span class="blink">></span> MENU';
        }
      });
    }
    
    // Handle scroll detection for hiding meta section
    function handleMetaScrollHide() {
      if (!isMetaVisible) return;
      
      const scrollY = window.pageYOffset || document.documentElement.scrollTop;
      const metaTop = metaSection.offsetTop;
      const metaBottom = metaTop + metaSection.offsetHeight;
      const viewportTop = scrollY;
      const viewportBottom = scrollY + window.innerHeight;
      
      // Check if user has scrolled away from meta section
      const hasScrolledAway = viewportBottom < metaTop - 100 || viewportTop > metaBottom + 100;
      
      if (hasScrolledAway) {
        // Clear any existing timer
        clearTimeout(metaScrollTimer);
        
        // Set timer to hide after 3 seconds
        metaScrollTimer = createTimeout(() => {
          hideMetaSection();
        }, 3000);
      } else {
        // User is still in or near meta section, cancel hide timer
        clearTimeout(metaScrollTimer);
      }
    }
    
    // Create throttled version for performance
    const throttledMetaScrollHide = throttle(handleMetaScrollHide, 200);
    
    // Add scroll listener for meta section hiding
    window.addEventListener('scroll', throttledMetaScrollHide);
    
    // Clean up meta scroll listener
    window.addEventListener('unload', () => {
      window.removeEventListener('scroll', throttledMetaScrollHide);
      clearTimeout(metaScrollTimer);
    });
  });
</script>
